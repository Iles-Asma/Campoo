{"version":3,"sources":["project/resolveNgrok.ts"],"names":["NGROK_REQUIRED_VERSION","EXPO_DEBUG","getenv","boolish","_ngrokInstance","resolveNgrokAsync","projectRoot","shouldPrompt","autoInstall","ngrok","findNgrokBinAsync","packageName","Promise","r","setTimeout","answer","message","initial","Logger","global","info","chalk","bold","packageManager","PackageManager","createForProject","silent","addGlobalAsync","e","Error","resolvePackageFromProjectAsync","ngrokPackagePath","pkg","require","semver","satisfies","version","ngrokPath","resolveGlobalPackageAsync","requireg","resolve","localInstance","globalInstance"],"mappings":"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","sourcesContent":["import * as PackageManager from '@expo/package-manager';\nimport chalk from 'chalk';\nimport getenv from 'getenv';\n// @ts-ignore\nimport requireg from 'requireg';\nimport resolveFrom from 'resolve-from';\nimport semver from 'semver';\n\nimport Logger from '../Logger';\nimport { confirmAsync } from '../Prompts';\n\nconst NGROK_REQUIRED_VERSION = '^2.4.3';\nconst EXPO_DEBUG = getenv.boolish('EXPO_DEBUG', false);\nlet _ngrokInstance: any | null = null;\n\nexport interface NgrokOptions {\n  authtoken?: string;\n  port?: string | number | null;\n  host?: string;\n  httpauth?: string;\n  region?: string;\n  configPath?: string;\n\n  proto?: 'http' | 'tcp' | 'tls';\n  addr?: string;\n  inspect?: boolean;\n  auth?: string;\n  host_header?: string;\n  bind_tls?: true | false | 'both';\n  subdomain?: string;\n  hostname?: string;\n  crt?: string;\n  key?: string;\n  client_cas?: string;\n  remote_addr?: string;\n}\n\nexport async function resolveNgrokAsync(\n  projectRoot: string,\n  {\n    shouldPrompt = true,\n    autoInstall = false,\n  }: { shouldPrompt?: boolean; autoInstall?: boolean } = {}\n): Promise<any> {\n  const ngrok = await findNgrokBinAsync(projectRoot);\n\n  if (!ngrok) {\n    const packageName = `@expo/ngrok@${NGROK_REQUIRED_VERSION}`;\n    if (shouldPrompt) {\n      if (!autoInstall) {\n        // Delay the prompt so it doesn't conflict with other dev tool logs\n        await new Promise(r => setTimeout(r, 100));\n      }\n      const answer =\n        autoInstall ||\n        (await confirmAsync({\n          message: `The package ${packageName} is required to use tunnels, would you like to install it globally?`,\n          initial: true,\n        }));\n      if (answer) {\n        Logger.global.info(`Installing ${packageName} for ${chalk.bold`tunnel`} support...`);\n\n        const packageManager = PackageManager.createForProject(projectRoot, {\n          silent: !EXPO_DEBUG,\n        });\n\n        try {\n          await packageManager.addGlobalAsync(packageName);\n          Logger.global.info(`Successfully installed ${packageName}`);\n        } catch (e) {\n          e.message = `Failed to install ${packageName} globally: ${e.message}`;\n          throw e;\n        }\n        return await resolveNgrokAsync(projectRoot, { shouldPrompt: false });\n      }\n    }\n    throw new Error(\n      `Please install ${packageName} and try again, or try using another hosting method like lan or localhost`\n    );\n  }\n  return ngrok;\n}\n\n// Resolve a copy that's installed in the project.\nasync function resolvePackageFromProjectAsync(projectRoot: string) {\n  try {\n    const ngrokPackagePath = resolveFrom(projectRoot, '@expo/ngrok/package.json');\n    const pkg = require(ngrokPackagePath);\n    if (pkg && semver.satisfies(pkg.version, NGROK_REQUIRED_VERSION)) {\n      const ngrokPath = resolveFrom(projectRoot, '@expo/ngrok');\n      if (EXPO_DEBUG) {\n        Logger.global.info(`Resolving @expo/ngrok from project: \"${ngrokPath}\"`);\n      }\n      return require(ngrokPath);\n    }\n  } catch {}\n  return null;\n}\n\n// Resolve a copy that's installed globally.\nasync function resolveGlobalPackageAsync() {\n  try {\n    // use true to disable the use of local packages.\n    const pkg = requireg('@expo/ngrok/package.json', true);\n    if (semver.satisfies(pkg.version, NGROK_REQUIRED_VERSION)) {\n      if (EXPO_DEBUG) {\n        Logger.global.info(\n          `Resolving global @expo/ngrok from: \"${requireg.resolve('@expo/ngrok')}\"`\n        );\n      }\n      return requireg('@expo/ngrok', true);\n    }\n  } catch {}\n\n  return null;\n}\n\nasync function findNgrokBinAsync(projectRoot: string): Promise<any> {\n  if (_ngrokInstance) {\n    return _ngrokInstance;\n  }\n\n  const localInstance = await resolvePackageFromProjectAsync(projectRoot);\n  if (localInstance) {\n    _ngrokInstance = localInstance;\n    return _ngrokInstance;\n  }\n\n  const globalInstance = await resolveGlobalPackageAsync();\n  if (globalInstance) {\n    _ngrokInstance = globalInstance;\n    return _ngrokInstance;\n  }\n\n  return null;\n}\n"],"file":"../../project/resolveNgrok.js","sourceRoot":"/@expo/xdl@59.0.19/src"}