"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.currentStatus = currentStatus;
exports.getLatestReleaseAsync = getLatestReleaseAsync;
exports.mergeAppDistributions = mergeAppDistributions;
exports.runHook = runHook;
exports.exportAppAsync = exportAppAsync;
exports.findReusableBuildAsync = findReusableBuildAsync;
exports.publishAsync = publishAsync;
exports.getBuildStatusAsync = getBuildStatusAsync;
exports.startBuildAsync = startBuildAsync;
exports.startReactNativeServerAsync = startReactNativeServerAsync;
exports.stopReactNativeServerAsync = stopReactNativeServerAsync;
exports.startExpoServerAsync = startExpoServerAsync;
exports.setOptionsAsync = setOptionsAsync;
exports.startAsync = startAsync;
exports.stopWebOnlyAsync = stopWebOnlyAsync;
exports.stopAsync = stopAsync;
Object.defineProperty(exports, "startTunnelsAsync", {
  enumerable: true,
  get: function () {
    return _ngrok().startTunnelsAsync;
  }
});
Object.defineProperty(exports, "stopTunnelsAsync", {
  enumerable: true,
  get: function () {
    return _ngrok().stopTunnelsAsync;
  }
});

function _config() {
  const data = require("@expo/config");

  _config = function () {
    return data;
  };

  return data;
}

function _paths() {
  const data = require("@expo/config/paths");

  _paths = function () {
    return data;
  };

  return data;
}

function _devServer() {
  const data = require("@expo/dev-server");

  _devServer = function () {
    return data;
  };

  return data;
}

function _jsonFile() {
  const data = _interopRequireDefault(require("@expo/json-file"));

  _jsonFile = function () {
    return data;
  };

  return data;
}

function _joi() {
  const data = _interopRequireDefault(require("@hapi/joi"));

  _joi = function () {
    return data;
  };

  return data;
}

function _assert() {
  const data = _interopRequireDefault(require("assert"));

  _assert = function () {
    return data;
  };

  return data;
}

function _axios() {
  const data = _interopRequireDefault(require("axios"));

  _axios = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _child_process() {
  const data = _interopRequireDefault(require("child_process"));

  _child_process = function () {
    return data;
  };

  return data;
}

function _crypto() {
  const data = _interopRequireDefault(require("crypto"));

  _crypto = function () {
    return data;
  };

  return data;
}

function _decache() {
  const data = _interopRequireDefault(require("decache"));

  _decache = function () {
    return data;
  };

  return data;
}

function _delayAsync() {
  const data = _interopRequireDefault(require("delay-async"));

  _delayAsync = function () {
    return data;
  };

  return data;
}

function _express() {
  const data = _interopRequireDefault(require("express"));

  _express = function () {
    return data;
  };

  return data;
}

function _freeportAsync() {
  const data = _interopRequireDefault(require("freeport-async"));

  _freeportAsync = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _getenv() {
  const data = _interopRequireDefault(require("getenv"));

  _getenv = function () {
    return data;
  };

  return data;
}

function _hashids() {
  const data = _interopRequireDefault(require("hashids"));

  _hashids = function () {
    return data;
  };

  return data;
}

function _escapeRegExp() {
  const data = _interopRequireDefault(require("lodash/escapeRegExp"));

  _escapeRegExp = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _readLastLines() {
  const data = _interopRequireDefault(require("read-last-lines"));

  _readLastLines = function () {
    return data;
  };

  return data;
}

function _semver() {
  const data = _interopRequireDefault(require("semver"));

  _semver = function () {
    return data;
  };

  return data;
}

function _slugify() {
  const data = _interopRequireDefault(require("slugify"));

  _slugify = function () {
    return data;
  };

  return data;
}

function _split() {
  const data = _interopRequireDefault(require("split"));

  _split = function () {
    return data;
  };

  return data;
}

function _treeKill() {
  const data = _interopRequireDefault(require("tree-kill"));

  _treeKill = function () {
    return data;
  };

  return data;
}

function _urlJoin() {
  const data = _interopRequireDefault(require("url-join"));

  _urlJoin = function () {
    return data;
  };

  return data;
}

function _util() {
  const data = require("util");

  _util = function () {
    return data;
  };

  return data;
}

function _uuid() {
  const data = _interopRequireDefault(require("uuid"));

  _uuid = function () {
    return data;
  };

  return data;
}

function _Analytics() {
  const data = _interopRequireDefault(require("./Analytics"));

  _Analytics = function () {
    return data;
  };

  return data;
}

function Android() {
  const data = _interopRequireWildcard(require("./Android"));

  Android = function () {
    return data;
  };

  return data;
}

function _ApiV() {
  const data = _interopRequireDefault(require("./ApiV2"));

  _ApiV = function () {
    return data;
  };

  return data;
}

function _Config() {
  const data = _interopRequireDefault(require("./Config"));

  _Config = function () {
    return data;
  };

  return data;
}

function ConnectionStatus() {
  const data = _interopRequireWildcard(require("./ConnectionStatus"));

  ConnectionStatus = function () {
    return data;
  };

  return data;
}

function DevSession() {
  const data = _interopRequireWildcard(require("./DevSession"));

  DevSession = function () {
    return data;
  };

  return data;
}

function EmbeddedAssets() {
  const data = _interopRequireWildcard(require("./EmbeddedAssets"));

  EmbeddedAssets = function () {
    return data;
  };

  return data;
}

function _Env() {
  const data = require("./Env");

  _Env = function () {
    return data;
  };

  return data;
}

function Exp() {
  const data = _interopRequireWildcard(require("./Exp"));

  Exp = function () {
    return data;
  };

  return data;
}

function _Logger() {
  const data = _interopRequireDefault(require("./Logger"));

  _Logger = function () {
    return data;
  };

  return data;
}

function _ProjectAssets() {
  const data = require("./ProjectAssets");

  _ProjectAssets = function () {
    return data;
  };

  return data;
}

function ProjectSettings() {
  const data = _interopRequireWildcard(require("./ProjectSettings"));

  ProjectSettings = function () {
    return data;
  };

  return data;
}

function Sentry() {
  const data = _interopRequireWildcard(require("./Sentry"));

  Sentry = function () {
    return data;
  };

  return data;
}

function ThirdParty() {
  const data = _interopRequireWildcard(require("./ThirdParty"));

  ThirdParty = function () {
    return data;
  };

  return data;
}

function UrlUtils() {
  const data = _interopRequireWildcard(require("./UrlUtils"));

  UrlUtils = function () {
    return data;
  };

  return data;
}

function _User() {
  const data = _interopRequireWildcard(require("./User"));

  _User = function () {
    return data;
  };

  return data;
}

function Versions() {
  const data = _interopRequireWildcard(require("./Versions"));

  Versions = function () {
    return data;
  };

  return data;
}

function Watchman() {
  const data = _interopRequireWildcard(require("./Watchman"));

  Watchman = function () {
    return data;
  };

  return data;
}

function Webpack() {
  const data = _interopRequireWildcard(require("./Webpack"));

  Webpack = function () {
    return data;
  };

  return data;
}

function _XDLError() {
  const data = _interopRequireDefault(require("./XDLError"));

  _XDLError = function () {
    return data;
  };

  return data;
}

function ExponentTools() {
  const data = _interopRequireWildcard(require("./detach/ExponentTools"));

  ExponentTools = function () {
    return data;
  };

  return data;
}

function TableText() {
  const data = _interopRequireWildcard(require("./logs/TableText"));

  TableText = function () {
    return data;
  };

  return data;
}

function _TerminalLink() {
  const data = require("./logs/TerminalLink");

  _TerminalLink = function () {
    return data;
  };

  return data;
}

function Doctor() {
  const data = _interopRequireWildcard(require("./project/Doctor"));

  Doctor = function () {
    return data;
  };

  return data;
}

function _ManifestHandler() {
  const data = require("./project/ManifestHandler");

  _ManifestHandler = function () {
    return data;
  };

  return data;
}

function ProjectUtils() {
  const data = _interopRequireWildcard(require("./project/ProjectUtils"));

  ProjectUtils = function () {
    return data;
  };

  return data;
}

function _errors() {
  const data = require("./project/errors");

  _errors = function () {
    return data;
  };

  return data;
}

function _ngrok() {
  const data = require("./project/ngrok");

  _ngrok = function () {
    return data;
  };

  return data;
}

function _ArtifactUtils() {
  const data = require("./tools/ArtifactUtils");

  _ArtifactUtils = function () {
    return data;
  };

  return data;
}

function _FormData() {
  const data = _interopRequireDefault(require("./tools/FormData"));

  _FormData = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const MINIMUM_BUNDLE_SIZE = 500;
const treekillAsync = (0, _util().promisify)(_treeKill().default);
const bundlePlatforms = ['android', 'ios'];

async function currentStatus(projectDir) {
  const {
    packagerPort,
    expoServerPort
  } = await ProjectSettings().readPackagerInfoAsync(projectDir);

  if (packagerPort && expoServerPort) {
    return 'running';
  } else if (packagerPort || expoServerPort) {
    return 'ill';
  } else {
    return 'exited';
  }
}

async function _getFreePortAsync(rangeStart) {
  const port = await (0, _freeportAsync().default)(rangeStart, {
    hostnames: [null, 'localhost']
  });

  if (!port) {
    throw new (_XDLError().default)('NO_PORT_FOUND', 'No available port found');
  }

  return port;
}

function _requireFromProject(modulePath, projectRoot, exp) {
  try {
    const fullPath = (0, _config().resolveModule)(modulePath, projectRoot, exp); // Clear the require cache for this module so get a fresh version of it
    // without requiring the user to restart Expo CLI

    (0, _decache().default)(fullPath); // $FlowIssue: doesn't work with dynamic requires

    return require(fullPath);
  } catch (e) {
    return null;
  }
}

async function getLatestReleaseAsync(projectRoot, options) {
  const user = await _User().default.ensureLoggedInAsync();

  const api = _ApiV().default.clientForUser(user);

  const {
    exp
  } = (0, _config().getConfig)(projectRoot, {
    skipSDKVersionRequirement: true
  });
  const result = await api.postAsync('publish/history', {
    owner: options.owner,
    slug: exp.slug,
    releaseChannel: options.releaseChannel,
    count: 1,
    platform: options.platform
  });
  const {
    queryResult
  } = result;

  if (queryResult && queryResult.length > 0) {
    return queryResult[0];
  } else {
    return null;
  }
}

function isSelfHostedIndex(obj) {
  return !!obj.sdkVersion;
} // Takes multiple exported apps in sourceDirs and coalesces them to one app in outputDir


async function mergeAppDistributions(projectRoot, sourceDirs, outputDir) {
  const assetPathToWrite = _path().default.resolve(projectRoot, outputDir, 'assets');

  await _fsExtra().default.ensureDir(assetPathToWrite);

  const bundlesPathToWrite = _path().default.resolve(projectRoot, outputDir, 'bundles');

  await _fsExtra().default.ensureDir(bundlesPathToWrite); // merge files from bundles and assets

  const androidIndexes = [];
  const iosIndexes = [];

  for (const sourceDir of sourceDirs) {
    const promises = []; // copy over assets/bundles from other src dirs to the output dir

    if (sourceDir !== outputDir) {
      // copy file over to assetPath
      const sourceAssetDir = _path().default.resolve(projectRoot, sourceDir, 'assets');

      const outputAssetDir = _path().default.resolve(projectRoot, outputDir, 'assets');

      const assetPromise = _fsExtra().default.copy(sourceAssetDir, outputAssetDir);

      promises.push(assetPromise); // copy files over to bundlePath

      const sourceBundleDir = _path().default.resolve(projectRoot, sourceDir, 'bundles');

      const outputBundleDir = _path().default.resolve(projectRoot, outputDir, 'bundles');

      const bundlePromise = _fsExtra().default.copy(sourceBundleDir, outputBundleDir);

      promises.push(bundlePromise);
      await Promise.all(promises);
    } // put index.jsons into memory


    const putJsonInMemory = async (indexPath, accumulator) => {
      const index = await _jsonFile().default.readAsync(indexPath);

      if (!isSelfHostedIndex(index)) {
        throw new (_XDLError().default)('INVALID_MANIFEST', `Invalid index.json, must specify an sdkVersion at ${indexPath}`);
      }

      if (Array.isArray(index)) {
        // index.json could also be an array
        accumulator.push(...index);
      } else {
        accumulator.push(index);
      }
    };

    const androidIndexPath = _path().default.resolve(projectRoot, sourceDir, 'android-index.json');

    await putJsonInMemory(androidIndexPath, androidIndexes);

    const iosIndexPath = _path().default.resolve(projectRoot, sourceDir, 'ios-index.json');

    await putJsonInMemory(iosIndexPath, iosIndexes);
  } // sort indexes by descending sdk value


  const getSortedIndex = indexes => {
    return indexes.sort((index1, index2) => {
      if (_semver().default.eq(index1.sdkVersion, index2.sdkVersion)) {
        _Logger().default.global.error(`Encountered multiple index.json with the same SDK version ${index1.sdkVersion}. This could result in undefined behavior.`);
      }

      return _semver().default.gte(index1.sdkVersion, index2.sdkVersion) ? -1 : 1;
    });
  };

  const sortedAndroidIndexes = getSortedIndex(androidIndexes);
  const sortedIosIndexes = getSortedIndex(iosIndexes); // Save the json arrays to disk

  await (0, _ArtifactUtils().writeArtifactSafelyAsync)(projectRoot, null, _path().default.join(outputDir, 'android-index.json'), JSON.stringify(sortedAndroidIndexes));
  await (0, _ArtifactUtils().writeArtifactSafelyAsync)(projectRoot, null, _path().default.join(outputDir, 'ios-index.json'), JSON.stringify(sortedIosIndexes));
}

function prepareHooks(hooks, hookType, projectRoot, exp) {
  const validHooks = [];

  if (hooks) {
    var _hooks$hookType;

    if (hooks[hookType]) {
      hooks[hookType].forEach(hook => {
        const {
          file
        } = hook;

        const fn = _requireFromProject(file, projectRoot, exp);

        if (typeof fn !== 'function') {
          _Logger().default.global.error(`Unable to load ${hookType} hook: '${file}'. The module does not export a function.`);
        } else {
          hook._fn = fn;
          validHooks.push(hook);
        }
      });
    }

    if (hooks[hookType] !== undefined && validHooks.length !== ((_hooks$hookType = hooks[hookType]) === null || _hooks$hookType === void 0 ? void 0 : _hooks$hookType.length)) {
      throw new (_XDLError().default)('HOOK_INITIALIZATION_ERROR', `Please fix your ${hookType} hook configuration`);
    }
  }

  return validHooks;
}

async function runHook(hook, hookOptions) {
  let result = hook._fn({
    config: hook.config,
    ...hookOptions
  }); // If it's a promise, wait for it to resolve


  if (result && result.then) {
    result = await result;
  }

  if (result) {
    _Logger().default.global.info({
      quiet: true
    }, result);
  }
}
/**
 * Returns true if we should use Metro using its JS APIs via @expo/dev-server (the modern and fast
 * way), false if we should fall back to spawning it as a subprocess (supported for backwards
 * compatibility with SDK39 and older).
 */


function shouldUseDevServer(exp) {
  return Versions().gteSdkVersion(exp, '40.0.0') || _getenv().default.boolish('EXPO_USE_DEV_SERVER', false);
}
/**
 * If the `eas` flag is true, the stucture of the outputDir will be:
â”œâ”€â”€ assets
â”‚   â””â”€â”€ *
â”œâ”€â”€ bundles
â”‚   â”œâ”€â”€ android-01ee6e3ab3e8c16a4d926c91808d5320.js
â”‚   â””â”€â”€ ios-ee8206cc754d3f7aa9123b7f909d94ea.js
â””â”€â”€ metadata.json

 * If the `eas` flag is not true, then this function is for self hosting 
 * and the outputDir will have the files created in the project directory the following way:
.
â”œâ”€â”€ android-index.json
â”œâ”€â”€ ios-index.json
â”œâ”€â”€ assets
â”‚   â””â”€â”€ 1eccbc4c41d49fd81840aef3eaabe862
â””â”€â”€ bundles
      â”œâ”€â”€ android-01ee6e3ab3e8c16a4d926c91808d5320.js
      â””â”€â”€ ios-ee8206cc754d3f7aa9123b7f909d94ea.js
 */


async function exportAppAsync(projectRoot, publicUrl, assetUrl, outputDir, options = {}, experimentalBundle) {
  var _options$publishOptio, _options$publishOptio2;

  const absoluteOutputDir = _path().default.resolve(process.cwd(), outputDir);

  const defaultTarget = (0, _config().getDefaultTarget)(projectRoot);
  const target = (_options$publishOptio = (_options$publishOptio2 = options.publishOptions) === null || _options$publishOptio2 === void 0 ? void 0 : _options$publishOptio2.target) !== null && _options$publishOptio !== void 0 ? _options$publishOptio : defaultTarget; // build the bundles
  // make output dirs if not exists

  const assetPathToWrite = _path().default.resolve(projectRoot, _path().default.join(outputDir, 'assets'));

  await _fsExtra().default.ensureDir(assetPathToWrite);

  const bundlesPathToWrite = _path().default.resolve(projectRoot, _path().default.join(outputDir, 'bundles'));

  await _fsExtra().default.ensureDir(bundlesPathToWrite);
  const {
    exp,
    pkg,
    hooks
  } = await _getPublishExpConfigAsync(projectRoot, options.publishOptions || {});
  const bundles = await buildPublishBundlesAsync(projectRoot, options.publishOptions, {
    dev: options.isDev,
    useDevServer: shouldUseDevServer(exp)
  });
  const iosBundle = bundles.ios.code;
  const androidBundle = bundles.android.code;

  const iosBundleHash = _crypto().default.createHash('md5').update(iosBundle).digest('hex');

  const iosBundleUrl = `ios-${iosBundleHash}.js`;

  const iosJsPath = _path().default.join(absoluteOutputDir, 'bundles', iosBundleUrl);

  const androidBundleHash = _crypto().default.createHash('md5').update(androidBundle).digest('hex');

  const androidBundleUrl = `android-${androidBundleHash}.js`;

  const androidJsPath = _path().default.join(absoluteOutputDir, 'bundles', androidBundleUrl);

  const relativeBundlePaths = {
    android: _path().default.join('bundles', androidBundleUrl),
    ios: _path().default.join('bundles', iosBundleUrl)
  };
  await (0, _ArtifactUtils().writeArtifactSafelyAsync)(projectRoot, null, iosJsPath, iosBundle);
  await (0, _ArtifactUtils().writeArtifactSafelyAsync)(projectRoot, null, androidJsPath, androidBundle);

  _Logger().default.global.info('Finished saving JS Bundles.');

  const {
    assets
  } = await (0, _ProjectAssets().exportAssetsAsync)({
    projectRoot,
    exp,
    hostedUrl: publicUrl,
    assetPath: 'assets',
    outputDir: absoluteOutputDir,
    bundles,
    experimentalBundle
  });

  if (experimentalBundle) {
    // Build metadata.json
    const fileMetadata = {
      android: {},
      ios: {}
    };
    bundlePlatforms.forEach(platform => {
      fileMetadata[platform].assets = [];
      bundles[platform].assets.forEach(asset => {
        fileMetadata[platform].assets = [...fileMetadata[platform].assets, ...asset.fileHashes.map(hash => {
          return {
            path: _path().default.join('assets', hash),
            ext: asset.type
          };
        })];
      });
      fileMetadata[platform].bundle = relativeBundlePaths[platform];
    });
    const metadata = {
      version: 0,
      bundler: 'metro',
      fileMetadata: fileMetadata
    };

    _fsExtra().default.writeFileSync(_path().default.resolve(outputDir, 'metadata.json'), JSON.stringify(metadata));
  }

  if (options.dumpAssetmap) {
    _Logger().default.global.info('Dumping asset map.');

    const assetmap = {};
    assets.forEach(asset => {
      assetmap[asset.hash] = asset;
    });
    await (0, _ArtifactUtils().writeArtifactSafelyAsync)(projectRoot, null, _path().default.join(absoluteOutputDir, 'assetmap.json'), JSON.stringify(assetmap));
  }

  const iosSourceMap = bundles.ios.map;
  const androidSourceMap = bundles.android.map; // build source maps

  if (options.dumpSourcemap) {
    // write the sourcemap files
    const iosMapName = `ios-${iosBundleHash}.map`;

    const iosMapPath = _path().default.join(absoluteOutputDir, 'bundles', iosMapName);

    await (0, _ArtifactUtils().writeArtifactSafelyAsync)(projectRoot, null, iosMapPath, iosSourceMap);
    const androidMapName = `android-${androidBundleHash}.map`;

    const androidMapPath = _path().default.join(absoluteOutputDir, 'bundles', androidMapName);

    await (0, _ArtifactUtils().writeArtifactSafelyAsync)(projectRoot, null, androidMapPath, androidSourceMap);

    if (target === 'managed' && _semver().default.lt(exp.sdkVersion, '40.0.0')) {
      // Remove original mapping to incorrect sourcemap paths
      // In SDK 40+ and bare projects, we no longer need to do this.
      _Logger().default.global.info('Configuring source maps');

      await truncateLastNLines(iosJsPath, 1);
      await truncateLastNLines(androidJsPath, 1);
    } // Add correct mapping to sourcemap paths


    await _fsExtra().default.appendFile(iosJsPath, `\n//# sourceMappingURL=${iosMapName}`);
    await _fsExtra().default.appendFile(androidJsPath, `\n//# sourceMappingURL=${androidMapName}`); // Make a debug html so user can debug their bundles

    _Logger().default.global.info('Preparing additional debugging files');

    const debugHtml = `
    <script src="${(0, _urlJoin().default)('bundles', iosBundleUrl)}"></script>
    <script src="${(0, _urlJoin().default)('bundles', androidBundleUrl)}"></script>
    Open up this file in Chrome. In the Javascript developer console, navigate to the Source tab.
    You can see a red coloured folder containing the original source code from your bundle.
    `;
    await (0, _ArtifactUtils().writeArtifactSafelyAsync)(projectRoot, null, _path().default.join(absoluteOutputDir, 'debug.html'), debugHtml);
  } // Skip the hooks and manifest creation if building for EAS.


  if (!experimentalBundle) {
    const validPostExportHooks = prepareHooks(hooks, 'postExport', projectRoot, exp); // Add assetUrl to manifest

    exp.assetUrlOverride = assetUrl;
    exp.publishedTime = new Date().toISOString();
    exp.commitTime = new Date().toISOString();
    exp.releaseId = _uuid().default.v4(); // generate revisionId and id the same way www does

    const hashIds = new (_hashids().default)(_uuid().default.v1(), 10);
    exp.revisionId = hashIds.encode(Date.now());

    if (options.isDev) {
      exp.developer = {
        tool: 'exp'
      };
    }

    if (!exp.slug) {
      throw new (_XDLError().default)('INVALID_MANIFEST', 'Must provide a slug field in the app.json manifest.');
    }

    let username = await _User().default.getCurrentUsernameAsync();

    if (!username) {
      username = _User().ANONYMOUS_USERNAME;
    }

    exp.id = `@${username}/${exp.slug}`; // save the android manifest

    const androidManifest = { ...exp,
      bundleUrl: (0, _urlJoin().default)(publicUrl, 'bundles', androidBundleUrl),
      platform: 'android',
      dependencies: Object.keys(pkg.dependencies)
    };
    await (0, _ArtifactUtils().writeArtifactSafelyAsync)(projectRoot, null, _path().default.join(absoluteOutputDir, 'android-index.json'), JSON.stringify(androidManifest)); // save the ios manifest

    const iosManifest = { ...exp,
      bundleUrl: (0, _urlJoin().default)(publicUrl, 'bundles', iosBundleUrl),
      platform: 'ios',
      dependencies: Object.keys(pkg.dependencies)
    };
    await (0, _ArtifactUtils().writeArtifactSafelyAsync)(projectRoot, null, _path().default.join(absoluteOutputDir, 'ios-index.json'), JSON.stringify(iosManifest));
    (0, _assert().default)(androidManifest, 'should have been assigned');
    (0, _assert().default)(iosManifest, 'should have been assigned');
    const hookOptions = {
      url: null,
      exp,
      iosBundle,
      iosSourceMap,
      iosManifest,
      androidBundle,
      androidSourceMap,
      androidManifest,
      projectRoot,
      log: msg => {
        _Logger().default.global.info({
          quiet: true
        }, msg);
      }
    };

    for (const hook of validPostExportHooks) {
      _Logger().default.global.info(`Running postExport hook: ${hook.file}`);

      try {
        runHook(hook, hookOptions);
      } catch (e) {
        _Logger().default.global.warn(`Warning: postExport hook '${hook.file}' failed: ${e.stack}`);
      }
    } // configure embedded assets for expo-updates or ExpoKit


    await EmbeddedAssets().configureAsync({
      projectRoot,
      pkg,
      exp,
      iosManifestUrl: (0, _urlJoin().default)(publicUrl, 'ios-index.json'),
      iosManifest,
      iosBundle,
      iosSourceMap,
      androidManifestUrl: (0, _urlJoin().default)(publicUrl, 'android-index.json'),
      androidManifest,
      androidBundle,
      androidSourceMap,
      target
    });
  }
} // truncate the last n lines in a file


async function truncateLastNLines(filePath, n) {
  const lines = await _readLastLines().default.read(filePath, n);
  const to_vanquish = lines.length;
  const {
    size
  } = await _fsExtra().default.stat(filePath);
  await _fsExtra().default.truncate(filePath, size - to_vanquish);
}

async function findReusableBuildAsync(releaseChannel, platform, sdkVersion, slug, owner) {
  const user = await _User().default.getCurrentUserAsync();
  const buildReuseStatus = await _ApiV().default.clientForUser(user).postAsync('standalone-build/reuse', {
    releaseChannel,
    platform,
    sdkVersion,
    slug,
    owner
  });
  return buildReuseStatus;
}

async function publishAsync(projectRoot, options = {}) {
  var _options$target, _options$releaseChann;

  options.target = (_options$target = options.target) !== null && _options$target !== void 0 ? _options$target : (0, _config().getDefaultTarget)(projectRoot);
  const target = options.target;
  const user = await _User().default.ensureLoggedInAsync();

  _Analytics().default.logEvent('Publish', {
    projectRoot,
    developerTool: _Config().default.developerTool
  });

  const validationStatus = await Doctor().validateWithNetworkAsync(projectRoot);

  if (validationStatus === Doctor().ERROR || validationStatus === Doctor().FATAL) {
    throw new (_XDLError().default)('PUBLISH_VALIDATION_ERROR', "Couldn't publish because errors were found. (See logs above.) Please fix the errors and try again.");
  } // Get project config


  const {
    exp,
    pkg,
    hooks
  } = await _getPublishExpConfigAsync(projectRoot, options); // Exit early if kernel builds are created with robot users

  if (exp.isKernel && user.kind === 'robot') {
    throw new (_XDLError().default)('ROBOT_ACCOUNT_ERROR', 'Kernel builds are not available for robot users');
  } // TODO: refactor this out to a function, throw error if length doesn't match


  const validPostPublishHooks = prepareHooks(hooks, 'postPublish', projectRoot, exp);
  const bundles = await buildPublishBundlesAsync(projectRoot, options, {
    useDevServer: shouldUseDevServer(exp)
  });
  const androidBundle = bundles.android.code;
  const iosBundle = bundles.ios.code;
  const files = [['index.ios.js', bundles.ios.code], ['index.android.js', bundles.android.code]]; // Account for inline source maps

  if (bundles.ios.map) {
    files.push([_chalk().default.dim('index.ios.js.map'), bundles.ios.map]);
  }

  if (bundles.android.map) {
    files.push([_chalk().default.dim('index.android.js.map'), bundles.android.map]);
  }

  _Logger().default.global.info('');

  _Logger().default.global.info(TableText().createFilesTable(files));

  _Logger().default.global.info('');

  _Logger().default.global.info(`ðŸ’¡ JavaScript bundle sizes affect startup time. ${_chalk().default.dim((0, _TerminalLink().learnMore)(`https://expo.fyi/javascript-bundle-sizes`))}`);

  _Logger().default.global.info('');

  await (0, _ProjectAssets().publishAssetsAsync)({
    projectRoot,
    exp,
    bundles
  });
  const hasHooks = validPostPublishHooks.length > 0;
  const shouldPublishAndroidMaps = !!exp.android && !!exp.android.publishSourceMapPath;
  const shouldPublishIosMaps = !!exp.ios && !!exp.ios.publishSourceMapPath;
  const androidSourceMap = hasHooks || shouldPublishAndroidMaps ? bundles.android.map : null;
  const iosSourceMap = hasHooks || shouldPublishIosMaps ? bundles.ios.map : null;
  let response;

  try {
    response = await _uploadArtifactsAsync({
      pkg,
      exp,
      iosBundle,
      androidBundle,
      options
    });
  } catch (e) {
    if (e.serverError === 'SCHEMA_VALIDATION_ERROR') {
      throw new Error(`There was an error validating your project schema. Check for any warnings about the contents of your app.json or app.config.js.`);
    }

    Sentry().captureException(e);
    throw e;
  }

  let androidManifest = {};
  let iosManifest = {};

  if (validPostPublishHooks.length || exp.ios && exp.ios.publishManifestPath || exp.android && exp.android.publishManifestPath || EmbeddedAssets().shouldEmbedAssetsForExpoUpdates(projectRoot, exp, pkg, target)) {
    [androidManifest, iosManifest] = await Promise.all([ExponentTools().getManifestAsync(response.url, {
      'Exponent-SDK-Version': exp.sdkVersion,
      'Exponent-Platform': 'android',
      'Expo-Release-Channel': options.releaseChannel,
      Accept: 'application/expo+json,application/json'
    }), ExponentTools().getManifestAsync(response.url, {
      'Exponent-SDK-Version': exp.sdkVersion,
      'Exponent-Platform': 'ios',
      'Expo-Release-Channel': options.releaseChannel,
      Accept: 'application/expo+json,application/json'
    })]);
    const hookOptions = {
      url: response.url,
      exp,
      iosBundle,
      iosSourceMap,
      iosManifest,
      androidBundle,
      androidSourceMap,
      androidManifest,
      projectRoot,
      log: msg => {
        _Logger().default.global.info({
          quiet: true
        }, msg);
      }
    };

    for (const hook of validPostPublishHooks) {
      _Logger().default.global.info(`Running postPublish hook: ${hook.file}`);

      try {
        runHook(hook, hookOptions);
      } catch (e) {
        _Logger().default.global.warn(`Warning: postPublish hook '${hook.file}' failed: ${e.stack}`);
      }
    }
  }

  const fullManifestUrl = response.url.replace('exp://', 'https://');
  await EmbeddedAssets().configureAsync({
    projectRoot,
    pkg,
    exp,
    releaseChannel: (_options$releaseChann = options.releaseChannel) !== null && _options$releaseChann !== void 0 ? _options$releaseChann : 'default',
    iosManifestUrl: fullManifestUrl,
    iosManifest,
    iosBundle,
    iosSourceMap,
    androidManifestUrl: fullManifestUrl,
    androidManifest,
    androidBundle,
    androidSourceMap,
    target
  }); // TODO: move to postPublish hook
  // This method throws early when a robot account is used for a kernel build

  if (exp.isKernel && user.kind !== 'robot') {
    await _handleKernelPublishedAsync({
      user,
      exp,
      projectRoot,
      url: response.url
    });
  }

  return { ...response,
    url: options.releaseChannel && options.releaseChannel !== 'default' ? `${response.url}?release-channel=${options.releaseChannel}` : response.url
  };
}

async function _uploadArtifactsAsync({
  exp,
  iosBundle,
  androidBundle,
  options,
  pkg
}) {
  _Logger().default.global.info('');

  _Logger().default.global.info('Uploading JavaScript bundles');

  const formData = new (_FormData().default)();
  formData.append('expJson', JSON.stringify(exp));
  formData.append('packageJson', JSON.stringify(pkg));
  formData.append('iosBundle', iosBundle, 'iosBundle');
  formData.append('androidBundle', androidBundle, 'androidBundle');
  formData.append('options', JSON.stringify(options));
  const user = await _User().default.ensureLoggedInAsync();

  const api = _ApiV().default.clientForUser(user);

  return await api.uploadFormDataAsync('publish/new', formData);
}

async function _getPublishExpConfigAsync(projectRoot, options) {
  if (options.releaseChannel != null && typeof options.releaseChannel !== 'string') {
    throw new (_XDLError().default)('INVALID_OPTIONS', 'releaseChannel must be a string');
  }

  options.releaseChannel = options.releaseChannel || 'default'; // Verify that exp/app.json and package.json exist

  const {
    exp: privateExp
  } = (0, _config().getConfig)(projectRoot);
  const {
    hooks
  } = privateExp;
  const {
    exp,
    pkg
  } = (0, _config().getConfig)(projectRoot, {
    isPublicConfig: true
  });
  const {
    sdkVersion
  } = exp; // Only allow projects to be published with UNVERSIONED if a correct token is set in env

  if (sdkVersion === 'UNVERSIONED' && !(0, _Env().maySkipManifestValidation)()) {
    throw new (_XDLError().default)('INVALID_OPTIONS', 'Cannot publish with sdkVersion UNVERSIONED.');
  }

  exp.locales = await ExponentTools().getResolvedLocalesAsync(projectRoot, exp);
  return {
    exp: { ...exp,
      sdkVersion: sdkVersion
    },
    pkg,
    hooks
  };
}

async function buildPublishBundlesAsync(projectRoot, publishOptions = {}, bundleOptions) {
  if (!bundleOptions.useDevServer) {
    try {
      await startReactNativeServerAsync({
        projectRoot,
        options: {
          nonPersistent: true,
          maxWorkers: publishOptions.maxWorkers,
          target: publishOptions.target,
          reset: publishOptions.resetCache
        },
        verbose: !publishOptions.quiet
      });
      return await fetchPublishBundlesAsync(projectRoot);
    } finally {
      await stopReactNativeServerAsync(projectRoot);
    }
  }

  const platforms = ['android', 'ios'];
  const [android, ios] = await (0, _devServer().bundleAsync)(projectRoot, {
    target: publishOptions.target,
    resetCache: publishOptions.resetCache,
    logger: ProjectUtils().getLogger(projectRoot),
    quiet: publishOptions.quiet
  }, platforms.map(platform => ({
    platform,
    entryPoint: Exp().determineEntryPoint(projectRoot, platform),
    dev: bundleOptions.dev
  })));
  return {
    android,
    ios
  };
} // Fetch iOS and Android bundles for publishing


async function fetchPublishBundlesAsync(projectRoot, opts) {
  const entryPoint = Exp().determineEntryPoint(projectRoot);
  const publishUrl = await UrlUtils().constructPublishUrlAsync(projectRoot, entryPoint, undefined, opts);
  const sourceMapUrl = await UrlUtils().constructSourceMapUrlAsync(projectRoot, entryPoint);
  const assetsUrl = await UrlUtils().constructAssetsUrlAsync(projectRoot, entryPoint);

  _Logger().default.global.info('Building iOS bundle');

  const iosBundle = await _getForPlatformAsync(projectRoot, publishUrl, 'ios', {
    errorCode: 'INVALID_BUNDLE',
    minLength: MINIMUM_BUNDLE_SIZE
  });

  _Logger().default.global.info('Building Android bundle');

  const androidBundle = await _getForPlatformAsync(projectRoot, publishUrl, 'android', {
    errorCode: 'INVALID_BUNDLE',
    minLength: MINIMUM_BUNDLE_SIZE
  });

  _Logger().default.global.info('Building source maps');

  const iosSourceMap = await _getForPlatformAsync(projectRoot, sourceMapUrl, 'ios', {
    errorCode: 'INVALID_BUNDLE',
    minLength: MINIMUM_BUNDLE_SIZE
  });
  const androidSourceMap = await _getForPlatformAsync(projectRoot, sourceMapUrl, 'android', {
    errorCode: 'INVALID_BUNDLE',
    minLength: MINIMUM_BUNDLE_SIZE
  });

  _Logger().default.global.info('Building asset maps');

  const iosAssetsJson = await _getForPlatformAsync(projectRoot, assetsUrl, 'ios', {
    errorCode: 'INVALID_ASSETS'
  });
  const androidAssetsJson = await _getForPlatformAsync(projectRoot, assetsUrl, 'android', {
    errorCode: 'INVALID_ASSETS'
  });
  return {
    android: {
      code: androidBundle,
      map: androidSourceMap,
      assets: JSON.parse(androidAssetsJson)
    },
    ios: {
      code: iosBundle,
      map: iosSourceMap,
      assets: JSON.parse(iosAssetsJson)
    }
  };
}

async function _getForPlatformAsync(projectRoot, url, platform, {
  errorCode,
  minLength
}) {
  const fullUrl = `${url}&platform=${platform}`;
  let response;

  try {
    response = await _axios().default.request({
      url: fullUrl,
      responseType: 'text',
      // Workaround for https://github.com/axios/axios/issues/907.
      // Without transformResponse, axios will parse the body as JSON regardless of the responseType/
      transformResponse: [data => data],
      proxy: false,
      validateStatus: status => status === 200,
      headers: {
        'Exponent-Platform': platform
      }
    });
  } catch (error) {
    if (error.response) {
      if (error.response.data) {
        let body;

        try {
          body = JSON.parse(error.response.data);
        } catch (e) {
          ProjectUtils().logError(projectRoot, 'expo', error.response.data);
        }

        if (body) {
          if (body.message) {
            ProjectUtils().logError(projectRoot, 'expo', body.message);
          } else {
            ProjectUtils().logError(projectRoot, 'expo', error.response.data);
          }
        }
      }

      throw new (_XDLError().default)(errorCode, `Packager URL ${fullUrl} returned unexpected code ${error.response.status}. ` + 'Please open your project in the Expo app and see if there are any errors. ' + 'Also scroll up and make sure there were no errors or warnings when opening your project.');
    } else {
      throw error;
    }
  }

  if (!response.data || minLength && response.data.length < minLength) {
    throw new (_XDLError().default)(errorCode, `Body is: ${response.data}`);
  }

  return response.data;
}

async function _handleKernelPublishedAsync({
  projectRoot,
  user,
  exp,
  url
}) {
  var _exp$kernel, _exp$kernel2;

  let kernelBundleUrl = `${_Config().default.api.scheme}://${_Config().default.api.host}`;

  if (_Config().default.api.port) {
    kernelBundleUrl = `${kernelBundleUrl}:${_Config().default.api.port}`;
  }

  kernelBundleUrl = `${kernelBundleUrl}/@${user.username}/${exp.slug}/bundle`;

  if ((_exp$kernel = exp.kernel) === null || _exp$kernel === void 0 ? void 0 : _exp$kernel.androidManifestPath) {
    const manifest = await ExponentTools().getManifestAsync(url, {
      'Exponent-SDK-Version': exp.sdkVersion,
      'Exponent-Platform': 'android',
      Accept: 'application/expo+json,application/json'
    });
    manifest.bundleUrl = kernelBundleUrl;
    manifest.sdkVersion = 'UNVERSIONED';
    await _fsExtra().default.writeFile(_path().default.resolve(projectRoot, exp.kernel.androidManifestPath), JSON.stringify(manifest));
  }

  if ((_exp$kernel2 = exp.kernel) === null || _exp$kernel2 === void 0 ? void 0 : _exp$kernel2.iosManifestPath) {
    const manifest = await ExponentTools().getManifestAsync(url, {
      'Exponent-SDK-Version': exp.sdkVersion,
      'Exponent-Platform': 'ios',
      Accept: 'application/expo+json,application/json'
    });
    manifest.bundleUrl = kernelBundleUrl;
    manifest.sdkVersion = 'UNVERSIONED';
    await _fsExtra().default.writeFile(_path().default.resolve(projectRoot, exp.kernel.iosManifestPath), JSON.stringify(manifest));
  }
}

async function getConfigAsync(projectRoot, options = {}) {
  if (!options.publicUrl) {
    // get the manifest from the project directory
    const {
      exp,
      pkg
    } = (0, _config().getConfig)(projectRoot);
    const configName = (0, _config().configFilename)(projectRoot);
    return {
      exp,
      pkg,
      configName: (0, _config().configFilename)(projectRoot),
      configPrefix: configName === 'app.json' ? 'expo.' : ''
    };
  } else {
    // get the externally hosted manifest
    return {
      exp: await ThirdParty().getManifest(options.publicUrl, options),
      configName: options.publicUrl,
      configPrefix: '',
      pkg: {}
    };
  }
}

function _validateManifest(options, exp, configName, configPrefix) {
  if (options.platform === 'ios' || options.platform === 'all') {
    if (!exp.ios || !exp.ios.bundleIdentifier) {
      throw new (_XDLError().default)('INVALID_MANIFEST', `Must specify a bundle identifier in order to build this experience for iOS. ` + `Please specify one in ${configName} at "${configPrefix}ios.bundleIdentifier"`);
    }
  }

  if (options.platform === 'android' || options.platform === 'all') {
    if (!exp.android || !exp.android.package) {
      throw new (_XDLError().default)('INVALID_MANIFEST', `Must specify a java package in order to build this experience for Android. ` + `Please specify one in ${configName} at "${configPrefix}android.package"`);
    }
  }
}

function _validateOptions(options) {
  const schema = _joi().default.object().keys({
    current: _joi().default.boolean(),
    mode: _joi().default.string(),
    platform: _joi().default.any().valid('ios', 'android', 'all'),
    expIds: _joi().default.array(),
    type: _joi().default.any().valid('archive', 'simulator', 'client', 'app-bundle', 'apk'),
    releaseChannel: _joi().default.string().regex(/[a-z\d][a-z\d._-]*/),
    bundleIdentifier: _joi().default.string().regex(/^[a-zA-Z][a-zA-Z0-9\-.]+$/),
    publicUrl: _joi().default.string(),
    sdkVersion: _joi().default.string().strict()
  });

  const {
    error
  } = schema.validate(options);

  if (error) {
    throw new (_XDLError().default)('INVALID_OPTIONS', error.toString());
  }
}

async function _getExpAsync(projectRoot, options) {
  const {
    exp,
    pkg,
    configName,
    configPrefix
  } = await getConfigAsync(projectRoot, options);

  if (!exp || !pkg) {
    throw new (_XDLError().default)('NO_PACKAGE_JSON', `Couldn't read ${configName} file in project at ${projectRoot}`);
  } // Support version and name being specified in package.json for legacy
  // support pre: exp.json


  if (!exp.version && 'version' in pkg && pkg.version) {
    exp.version = pkg.version;
  }

  if (!exp.name && 'name' in pkg && typeof pkg.name === 'string') {
    exp.name = pkg.name;
  }

  if (!exp.slug && typeof exp.name === 'string') {
    exp.slug = (0, _slugify().default)(exp.name.toLowerCase());
  }

  return {
    exp,
    configName,
    configPrefix
  };
}

async function getBuildStatusAsync(projectRoot, options = {}) {
  const user = await _User().default.ensureLoggedInAsync();
  (0, _errors().assertValidProjectRoot)(projectRoot);

  _validateOptions(options);

  const {
    exp
  } = await _getExpAsync(projectRoot, options);

  const api = _ApiV().default.clientForUser(user);

  return await api.postAsync('build/status', {
    manifest: exp,
    options
  });
}

async function startBuildAsync(projectRoot, options = {}) {
  const user = await _User().default.ensureLoggedInAsync();
  (0, _errors().assertValidProjectRoot)(projectRoot);

  _validateOptions(options);

  const {
    exp,
    configName,
    configPrefix
  } = await _getExpAsync(projectRoot, options);

  _validateManifest(options, exp, configName, configPrefix);

  _Analytics().default.logEvent('Build Shell App', {
    projectRoot,
    developerTool: _Config().default.developerTool,
    platform: options.platform
  });

  const api = _ApiV().default.clientForUser(user);

  return await api.putAsync('build/start', {
    manifest: exp,
    options
  });
}

async function _waitForRunningAsync(projectRoot, url, retries = 300) {
  try {
    const response = await _axios().default.request({
      url,
      responseType: 'text',
      proxy: false
    });

    if (/packager-status:running/.test(response.data)) {
      return true;
    } else if (retries === 0) {
      ProjectUtils().logError(projectRoot, 'expo', `Could not get status from Metro bundler. Server response: ${response.data}`);
    }
  } catch (e) {
    if (retries === 0) {
      ProjectUtils().logError(projectRoot, 'expo', `Could not get status from Metro bundler. ${e.message}`);
    }
  }

  if (retries <= 0) {
    throw new Error('Connecting to Metro bundler failed.');
  } else {
    await (0, _delayAsync().default)(100);
    return _waitForRunningAsync(projectRoot, url, retries - 1);
  }
} // The --verbose flag is intended for react-native-cli/metro, not expo-cli


const METRO_VERBOSE_WARNING = 'Run CLI with --verbose flag for more details.'; // Remove these constants and related code when SDK35 isn't supported anymore
// Context: https://github.com/expo/expo-cli/issues/1074

const NODE_12_WINDOWS_METRO_ERROR = `Invalid regular expression: /(.*\\__fixtures__\\.*|node_modules[\\]react[\\]dist[\\].*|website\\node_modules\\.*|heapCapture\\bundle.js|.*\\__tests__\\.*)$/: Unterminated character class`;
const NODE_12_WINDOWS_METRO_SUGGESTION = `\nUnable to start the project due to a documented incompatibility between Node 12 LTS and Expo SDK 35 on Windows.
Please refer to this GitHub comment for a solution:
https://github.com/expo/expo-cli/issues/1074#issuecomment-559220752\n`;

function _logPackagerOutput(projectRoot, level, data) {
  let output = data.toString();

  if (!output) {
    return;
  } // Temporarily hide warnings about duplicate providesModule declarations
  // under react-native


  if (_isIgnorableDuplicateModuleWarning(projectRoot, level, output)) {
    ProjectUtils().logDebug(projectRoot, 'expo', `Suppressing @providesModule warning: ${output}`, 'project-suppress-providesmodule-warning');
    return;
  }

  if (_isIgnorableMetroConsoleOutput(output) || _isIgnorableRnpmWarning(output)) {
    ProjectUtils().logDebug(projectRoot, 'expo', output);
    return;
  }

  if (output.includes(NODE_12_WINDOWS_METRO_ERROR)) {
    ProjectUtils().logError(projectRoot, 'expo', NODE_12_WINDOWS_METRO_SUGGESTION);
    return;
  }

  if (output.includes(METRO_VERBOSE_WARNING)) {
    output = output.replace(METRO_VERBOSE_WARNING, '');
  }

  if (/^Scanning folders for symlinks in /.test(output)) {
    ProjectUtils().logDebug(projectRoot, 'metro', output);
    return;
  }

  if (level === 'info') {
    ProjectUtils().logInfo(projectRoot, 'metro', output);
  } else {
    ProjectUtils().logError(projectRoot, 'metro', output);
  }
}

function _isIgnorableMetroConsoleOutput(output) {
  // As of react-native 0.61.x, Metro prints console logs from the device to console, without
  // passing them through the custom log reporter.
  //
  // Managed apps have a separate remote logging implementation included in the Expo SDK,
  // (see: _handleDeviceLogs), so we can just ignore these device logs from Metro.
  // if (/^ () /)
  //
  // These logs originate from:
  // https://github.com/facebook/metro/blob/e8181fb9db7db31adf7d1ed9ab840f54449ef238/packages/metro/src/lib/logToConsole.js#L50
  return /^\s+(INFO|WARN|LOG|GROUP|DEBUG) /.test(output);
}

function _isIgnorableRnpmWarning(output) {
  return output.startsWith('warn The following packages use deprecated "rnpm" config that will stop working from next release');
}

function _isIgnorableDuplicateModuleWarning(projectRoot, level, output) {
  if (level !== 'error' || !output.startsWith('jest-haste-map: @providesModule naming collision:')) {
    return false;
  }

  const reactNativeNodeModulesPath = _path().default.join(projectRoot, 'node_modules', 'react-native', 'node_modules');

  const reactNativeNodeModulesPattern = (0, _escapeRegExp().default)(reactNativeNodeModulesPath);
  const reactNativeNodeModulesCollisionRegex = new RegExp(`Paths: ${reactNativeNodeModulesPattern}.+ collides with ${reactNativeNodeModulesPattern}.+`);
  return reactNativeNodeModulesCollisionRegex.test(output);
}

function _isIgnorableBugReportingExtraData(body) {
  return body.length === 2 && body[0] === 'BugReporting extraData:';
}

function _isAppRegistryStartupMessage(body) {
  return body.length === 1 && (/^Running application "main" with appParams:/.test(body[0]) || /^Running "main" with \{/.test(body[0]));
}

function _handleDeviceLogs(projectRoot, deviceId, deviceName, logs) {
  for (let i = 0; i < logs.length; i++) {
    const log = logs[i];
    let body = typeof log.body === 'string' ? [log.body] : log.body;
    let {
      level
    } = log;

    if (_isIgnorableBugReportingExtraData(body)) {
      level = 'debug';
    }

    if (_isAppRegistryStartupMessage(body)) {
      body = [`Running application on ${deviceName}.`];
    }

    const args = body.map(obj => {
      if (typeof obj === 'undefined') {
        return 'undefined';
      }

      if (obj === 'null') {
        return 'null';
      }

      if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean') {
        return obj;
      }

      try {
        return JSON.stringify(obj);
      } catch (e) {
        return obj.toString();
      }
    });
    const logLevel = level === 'info' || level === 'warn' || level === 'error' || level === 'debug' ? level : 'info';
    ProjectUtils().getLogger(projectRoot)[logLevel]({
      tag: 'device',
      deviceId,
      deviceName,
      groupDepth: log.groupDepth,
      shouldHide: log.shouldHide,
      includesStack: log.includesStack
    }, ...args);
  }
}

async function startReactNativeServerAsync({
  projectRoot,
  options = {},
  exp = (0, _config().getConfig)(projectRoot).exp,
  verbose = true
}) {
  (0, _errors().assertValidProjectRoot)(projectRoot);
  await stopReactNativeServerAsync(projectRoot);
  await Watchman().addToPathAsync(); // Attempt to fix watchman if it's hanging

  await Watchman().unblockAndGetVersionAsync(projectRoot);
  let packagerPort = await _getFreePortAsync(19001); // Create packager options

  const customLogReporterPath = require.resolve(_path().default.join(__dirname, '../build/reporter')); // TODO: Bacon: Support .mjs (short-lived JS modules extension that some packages use)


  const sourceExtsConfig = {
    isTS: true,
    isReact: true,
    isModern: false
  };
  const sourceExts = options.target === 'bare' ? (0, _paths().getBareExtensions)([], sourceExtsConfig) : (0, _paths().getManagedExtensions)([], sourceExtsConfig);
  let packagerOpts = {
    port: packagerPort,
    customLogReporterPath,
    sourceExts
  };

  if (options.nonPersistent && Versions().lteSdkVersion(exp, '32.0.0')) {
    packagerOpts.nonPersistent = true;
  }

  if (Versions().gteSdkVersion(exp, '33.0.0')) {
    // starting with SDK 37, we bundle this plugin with the expo-asset package instead of expo,
    // so check there first and fall back to expo if we can't find it in expo-asset
    try {
      packagerOpts.assetPlugins = (0, _config().resolveModule)('expo-asset/tools/hashAssetFiles', projectRoot, exp);
    } catch (e) {
      try {
        packagerOpts.assetPlugins = (0, _config().resolveModule)('expo/tools/hashAssetFiles', projectRoot, exp);
      } catch (e) {
        throw new Error('Unable to find the expo-asset package in the current project. Install it and try again.');
      }
    }
  }

  if (options.maxWorkers) {
    packagerOpts['max-workers'] = options.maxWorkers;
  }

  if (!Versions().gteSdkVersion(exp, '16.0.0')) {
    delete packagerOpts.customLogReporterPath;
  }

  const userPackagerOpts = exp.packagerOpts;

  if (userPackagerOpts) {
    var _userPackagerOpts$sou;

    // The RN CLI expects rn-cli.config.js's path to be absolute. We use the
    // project root to resolve relative paths since that was the original
    // behavior of the RN CLI.
    if (userPackagerOpts.config) {
      userPackagerOpts.config = _path().default.resolve(projectRoot, userPackagerOpts.config);
    } // Provide a fallback if the value isn't given


    const userSourceExts = (_userPackagerOpts$sou = userPackagerOpts.sourceExts) !== null && _userPackagerOpts$sou !== void 0 ? _userPackagerOpts$sou : [];
    packagerOpts = { ...packagerOpts,
      ...userPackagerOpts,
      // In order to prevent people from forgetting to include the .expo extension or other things
      // NOTE(brentvatne): we should probably do away with packagerOpts soon in favor of @expo/metro-config!
      sourceExts: [...new Set([...packagerOpts.sourceExts, ...userSourceExts])]
    };

    if (userPackagerOpts.port !== undefined && userPackagerOpts.port !== null) {
      packagerPort = userPackagerOpts.port;
    }
  }

  const cliOpts = ['start'];

  for (const [key, val] of Object.entries(packagerOpts)) {
    // If the packager opt value is boolean, don't set
    // --[opt] [value], just set '--opt'
    if (val && typeof val === 'boolean') {
      cliOpts.push(`--${key}`);
    } else if (val) {
      cliOpts.push(`--${key}`, val);
    }
  }

  if (process.env.EXPO_DEBUG) {
    cliOpts.push('--verbose');
  }

  if (options.reset) {
    cliOpts.push('--reset-cache');
  } // Get custom CLI path from project package.json, but fall back to node_module path


  const defaultCliPath = (0, _config().resolveModule)('react-native/local-cli/cli.js', projectRoot, exp);
  const cliPath = exp.rnCliPath || defaultCliPath;
  let nodePath; // When using a custom path for the RN CLI, we want it to use the project
  // root to look up config files and Node modules

  if (exp.rnCliPath) {
    nodePath = _nodePathForProjectRoot(projectRoot);
  } else {
    nodePath = null;
  } // Run the copy of Node that's embedded in Electron by setting the
  // ELECTRON_RUN_AS_NODE environment variable
  // Note: the CLI script sets up graceful-fs and sets ulimit to 4096 in the
  // child process


  const nodePathEnv = nodePath ? {
    NODE_PATH: nodePath
  } : {};

  const packagerProcess = _child_process().default.fork(cliPath, cliOpts, {
    cwd: projectRoot,
    env: { ...process.env,
      NODE_OPTIONS: process.env.METRO_NODE_OPTIONS,
      REACT_NATIVE_APP_ROOT: projectRoot,
      ELECTRON_RUN_AS_NODE: '1',
      ...nodePathEnv
    },
    silent: true
  });

  await ProjectSettings().setPackagerInfoAsync(projectRoot, {
    packagerPort,
    packagerPid: packagerProcess.pid
  }); // TODO: do we need this? don't know if it's ever called

  process.on('exit', () => {
    (0, _treeKill().default)(packagerProcess.pid);
  });

  if (!packagerProcess.stdout) {
    throw new Error('Expected spawned process to have a stdout stream, but none was found.');
  }

  if (!packagerProcess.stderr) {
    throw new Error('Expected spawned process to have a stderr stream, but none was found.');
  }

  packagerProcess.stdout.setEncoding('utf8');
  packagerProcess.stderr.setEncoding('utf8');
  packagerProcess.stdout.pipe((0, _split().default)()).on('data', data => {
    if (verbose) {
      _logPackagerOutput(projectRoot, 'info', data);
    }
  });
  packagerProcess.stderr.on('data', data => {
    if (verbose) {
      _logPackagerOutput(projectRoot, 'error', data);
    }
  });
  const exitPromise = new Promise((resolve, reject) => {
    packagerProcess.once('exit', async code => {
      ProjectUtils().logDebug(projectRoot, 'expo', `Metro Bundler process exited with code ${code}`);

      if (code) {
        reject(new Error(`Metro Bundler process exited with code ${code}`));
      } else {
        resolve();
      }

      try {
        await ProjectSettings().setPackagerInfoAsync(projectRoot, {
          packagerPort: null,
          packagerPid: null
        });
      } catch (e) {}
    });
  });
  const packagerUrl = await UrlUtils().constructBundleUrlAsync(projectRoot, {
    urlType: 'http',
    hostType: 'localhost'
  });
  await Promise.race([_waitForRunningAsync(projectRoot, `${packagerUrl}/status`), exitPromise]);
} // Simulate the node_modules resolution
// If you project dir is /Jesse/Expo/Universe/BubbleBounce, returns
// "/Jesse/node_modules:/Jesse/Expo/node_modules:/Jesse/Expo/Universe/node_modules:/Jesse/Expo/Universe/BubbleBounce/node_modules"


function _nodePathForProjectRoot(projectRoot) {
  const paths = [];

  let directory = _path().default.resolve(projectRoot);

  while (true) {
    paths.push(_path().default.join(directory, 'node_modules'));

    const parentDirectory = _path().default.dirname(directory);

    if (directory === parentDirectory) {
      break;
    }

    directory = parentDirectory;
  }

  return paths.join(_path().default.delimiter);
}

async function stopReactNativeServerAsync(projectRoot) {
  (0, _errors().assertValidProjectRoot)(projectRoot);
  const packagerInfo = await ProjectSettings().readPackagerInfoAsync(projectRoot);

  if (!packagerInfo.packagerPort || !packagerInfo.packagerPid) {
    ProjectUtils().logDebug(projectRoot, 'expo', `No packager found for project at ${projectRoot}.`);
    return;
  }

  ProjectUtils().logDebug(projectRoot, 'expo', `Killing packager process tree: ${packagerInfo.packagerPid}`);

  try {
    await treekillAsync(packagerInfo.packagerPid, 'SIGKILL');
  } catch (e) {
    ProjectUtils().logDebug(projectRoot, 'expo', `Error stopping packager process: ${e.toString()}`);
  }

  await ProjectSettings().setPackagerInfoAsync(projectRoot, {
    packagerPort: null,
    packagerPid: null
  });
}

async function startExpoServerAsync(projectRoot, options) {
  (0, _errors().assertValidProjectRoot)(projectRoot);
  await stopExpoServerAsync(projectRoot);
  const app = (0, _express().default)();
  app.use(_express().default.json({
    limit: '10mb'
  }));
  app.use(_express().default.urlencoded({
    limit: '10mb',
    extended: true
  }));

  if ((ConnectionStatus().isOffline() ? await Doctor().validateWithoutNetworkAsync(projectRoot) : await Doctor().validateWithNetworkAsync(projectRoot)) === Doctor().FATAL) {
    throw new Error(`Couldn't start project. Please fix the errors and restart the project.`);
  } // Serve the manifest.


  const manifestHandler = (0, _ManifestHandler().getManifestHandler)(projectRoot);
  app.get('/', manifestHandler);
  app.get('/manifest', manifestHandler);
  app.get('/index.exp', manifestHandler);
  app.post('/logs', async (req, res) => {
    try {
      const deviceId = req.get('Device-Id');
      const deviceName = req.get('Device-Name');

      if (deviceId && deviceName && req.body) {
        _handleDeviceLogs(projectRoot, deviceId, deviceName, req.body);
      }
    } catch (e) {
      ProjectUtils().logError(projectRoot, 'expo', `Error getting device logs: ${e} ${e.stack}`);
    }

    res.send('Success');
  });
  app.post('/shutdown', async (req, res) => {
    server.close();
    res.send('Success');
  });
  const expRc = await (0, _config().readExpRcAsync)(projectRoot);
  const expoServerPort = expRc.manifestPort ? expRc.manifestPort : await _getFreePortAsync(19000);
  await ProjectSettings().setPackagerInfoAsync(projectRoot, {
    expoServerPort
  });
  let server = app.listen(expoServerPort, () => {
    const info = server.address();
    const host = info.address;
    const port = info.port;
    ProjectUtils().logDebug(projectRoot, 'expo', `Local server listening at http://${host}:${port}`);
  });
}

async function stopExpoServerAsync(projectRoot) {
  (0, _errors().assertValidProjectRoot)(projectRoot);
  const packagerInfo = await ProjectSettings().readPackagerInfoAsync(projectRoot);

  if (packagerInfo && packagerInfo.expoServerPort) {
    try {
      await _axios().default.request({
        method: 'post',
        url: `http://127.0.0.1:${packagerInfo.expoServerPort}/shutdown`
      });
    } catch (e) {}
  }

  await ProjectSettings().setPackagerInfoAsync(projectRoot, {
    expoServerPort: null
  });
}

async function startDevServerAsync(projectRoot, startOptions) {
  (0, _errors().assertValidProjectRoot)(projectRoot);
  const port = await _getFreePortAsync(19000); // Create packager options

  await ProjectSettings().setPackagerInfoAsync(projectRoot, {
    expoServerPort: port,
    packagerPort: port
  });
  const options = {
    port,
    logger: ProjectUtils().getLogger(projectRoot)
  };

  if (startOptions.reset) {
    options.resetCache = true;
  }

  if (startOptions.maxWorkers != null) {
    options.maxWorkers = startOptions.maxWorkers;
  }

  if (startOptions.target) {
    // EXPO_TARGET is used by @expo/metro-config to determine the target when getDefaultConfig is
    // called from metro.config.js.
    process.env.EXPO_TARGET = startOptions.target;
  }

  const {
    middleware
  } = await (0, _devServer().runMetroDevServerAsync)(projectRoot, options);
  middleware.use((0, _ManifestHandler().getManifestHandler)(projectRoot));
}

async function setOptionsAsync(projectRoot, options) {
  (0, _errors().assertValidProjectRoot)(projectRoot); // Check to make sure all options are valid

  if (options.packagerPort != null && !Number.isInteger(options.packagerPort)) {
    throw new (_XDLError().default)('INVALID_OPTIONS', 'packagerPort must be an integer');
  }

  await ProjectSettings().setPackagerInfoAsync(projectRoot, options);
}

async function startAsync(projectRoot, {
  exp = (0, _config().getConfig)(projectRoot).exp,
  ...options
} = {}, verbose = true) {
  var _exp$sdkVersion;

  (0, _errors().assertValidProjectRoot)(projectRoot);

  _Analytics().default.logEvent('Start Project', {
    projectRoot,
    developerTool: _Config().default.developerTool,
    sdkVersion: (_exp$sdkVersion = exp.sdkVersion) !== null && _exp$sdkVersion !== void 0 ? _exp$sdkVersion : null
  });

  if (options.webOnly) {
    await Webpack().restartAsync(projectRoot, options);
    DevSession().startSession(projectRoot, exp, 'web');
    return exp;
  } else if (shouldUseDevServer(exp) || options.devClient) {
    await startDevServerAsync(projectRoot, options);
    DevSession().startSession(projectRoot, exp, 'native');
  } else {
    await startExpoServerAsync(projectRoot, options);
    await startReactNativeServerAsync({
      projectRoot,
      exp,
      options,
      verbose
    });
    DevSession().startSession(projectRoot, exp, 'native');
  }

  const {
    hostType
  } = await ProjectSettings().readAsync(projectRoot);

  if (!_Config().default.offline && hostType === 'tunnel') {
    try {
      await (0, _ngrok().startTunnelsAsync)(projectRoot);
    } catch (e) {
      ProjectUtils().logDebug(projectRoot, 'expo', `Error starting tunnel ${e.message}`);
    }
  }

  return exp;
}

async function _stopInternalAsync(projectRoot) {
  DevSession().stopSession();
  await Webpack().stopAsync(projectRoot);
  ProjectUtils().logInfo(projectRoot, 'expo', '\u203A Closing Expo server');
  await stopExpoServerAsync(projectRoot);
  ProjectUtils().logInfo(projectRoot, 'expo', '\u203A Stopping Metro bundler');
  await stopReactNativeServerAsync(projectRoot);

  if (!_Config().default.offline) {
    try {
      await (0, _ngrok().stopTunnelsAsync)(projectRoot);
    } catch (e) {
      ProjectUtils().logDebug(projectRoot, 'expo', `Error stopping ngrok ${e.message}`);
    }
  }

  await Android().maybeStopAdbDaemonAsync();
}

async function stopWebOnlyAsync(projectDir) {
  await Webpack().stopAsync(projectDir);
  await DevSession().stopSession();
}

async function stopAsync(projectDir) {
  const result = await Promise.race([_stopInternalAsync(projectDir), new Promise(resolve => setTimeout(resolve, 2000, 'stopFailed'))]);

  if (result === 'stopFailed') {
    // find RN packager and ngrok pids, attempt to kill them manually
    const {
      packagerPid,
      ngrokPid
    } = await ProjectSettings().readPackagerInfoAsync(projectDir);

    if (packagerPid) {
      try {
        process.kill(packagerPid);
      } catch (e) {}
    }

    if (ngrokPid) {
      try {
        process.kill(ngrokPid);
      } catch (e) {}
    }

    await ProjectSettings().setPackagerInfoAsync(projectDir, {
      expoServerPort: null,
      packagerPort: null,
      packagerPid: null,
      expoServerNgrokUrl: null,
      packagerNgrokUrl: null,
      ngrokPid: null,
      webpackServerPort: null
    });
  }
}
//# sourceMappingURL=__sourcemaps__/Project.js.map
