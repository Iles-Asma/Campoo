import { ExpoConfig, Hook, HookArguments, ProjectTarget } from '@expo/config';
import { startTunnelsAsync, stopTunnelsAsync } from './project/ngrok';
declare type LoadedHook = Hook & {
    _fn: (input: HookArguments) => any;
};
export declare type StartOptions = {
    devClient?: boolean;
    reset?: boolean;
    nonInteractive?: boolean;
    nonPersistent?: boolean;
    maxWorkers?: number;
    webOnly?: boolean;
    target?: ProjectTarget;
};
declare type PublishOptions = {
    releaseChannel?: string;
    target?: ProjectTarget;
    resetCache?: boolean;
    maxWorkers?: number;
    quiet?: boolean;
};
declare type Release = {
    fullName: string;
    channel: string;
    channelId: string;
    publicationId: string;
    appVersion: string;
    sdkVersion: string;
    publishedTime: string;
    platform: string;
};
declare type ProjectStatus = 'running' | 'ill' | 'exited';
export declare function currentStatus(projectDir: string): Promise<ProjectStatus>;
export declare function getLatestReleaseAsync(projectRoot: string, options: {
    releaseChannel: string;
    platform: string;
    owner?: string;
}): Promise<Release | null>;
export declare function mergeAppDistributions(projectRoot: string, sourceDirs: string[], outputDir: string): Promise<void>;
export declare function runHook(hook: LoadedHook, hookOptions: Omit<HookArguments, 'config'>): Promise<void>;
/**
 * If the `eas` flag is true, the stucture of the outputDir will be:
├── assets
│   └── *
├── bundles
│   ├── android-01ee6e3ab3e8c16a4d926c91808d5320.js
│   └── ios-ee8206cc754d3f7aa9123b7f909d94ea.js
└── metadata.json

 * If the `eas` flag is not true, then this function is for self hosting
 * and the outputDir will have the files created in the project directory the following way:
.
├── android-index.json
├── ios-index.json
├── assets
│   └── 1eccbc4c41d49fd81840aef3eaabe862
└── bundles
      ├── android-01ee6e3ab3e8c16a4d926c91808d5320.js
      └── ios-ee8206cc754d3f7aa9123b7f909d94ea.js
 */
export declare function exportAppAsync(projectRoot: string, publicUrl: string, assetUrl: string, outputDir: string, options: {
    isDev?: boolean | undefined;
    dumpAssetmap?: boolean | undefined;
    dumpSourcemap?: boolean | undefined;
    publishOptions?: PublishOptions | undefined;
} | undefined, experimentalBundle: boolean): Promise<void>;
export declare function findReusableBuildAsync(releaseChannel: string, platform: string, sdkVersion: string, slug: string, owner?: string): Promise<{
    downloadUrl?: string;
    canReuse: boolean;
}>;
export interface PublishedProjectResult {
    /**
     * Project manifest URL
     */
    url: string;
    /**
     * TODO: What is this?
     */
    ids: string[];
    /**
     * TODO: What is this? Where does it come from?
     */
    err?: string;
}
export declare function publishAsync(projectRoot: string, options?: PublishOptions): Promise<PublishedProjectResult>;
declare type GetExpConfigOptions = {
    current?: boolean;
    mode?: string;
    platform?: 'android' | 'ios' | 'all';
    expIds?: string[];
    type?: string;
    releaseChannel?: string;
    bundleIdentifier?: string;
    publicUrl?: string;
    sdkVersion?: string;
};
declare type JobState = 'pending' | 'started' | 'in-progress' | 'finished' | 'errored' | 'sent-to-queue';
export declare type TurtleMode = 'normal' | 'high' | 'high_only';
export interface BuildJobFields {
    id: string;
    experienceName: string;
    status: JobState;
    platform: 'ios' | 'android';
    userId: string | null;
    experienceId: string;
    artifactId: string | null;
    nonce: string | null;
    artifacts: {
        url?: string;
        manifestPlistUrl?: string;
    } | null;
    config: {
        buildType?: string;
        releaseChannel?: string;
        bundleIdentifier?: string;
    };
    logs: object | null;
    extraData: {
        request_id?: string;
        turtleMode?: TurtleMode;
    } | null;
    created: Date;
    updated: Date;
    expirationDate: Date;
    sdkVersion: string | null;
    turtleVersion: string | null;
    buildDuration: number | null;
    priority: string;
    accountId: string | null;
}
export declare type BuildStatusResult = {
    jobs?: BuildJobFields[];
    err?: null;
    userHasBuiltAppBefore: boolean;
    userHasBuiltExperienceBefore: boolean;
    canPurchasePriorityBuilds?: boolean;
    numberOfRemainingPriorityBuilds?: number;
    hasUnlimitedPriorityBuilds?: boolean;
};
export declare type BuildCreatedResult = {
    id: string;
    ids: string[];
    priority: 'normal' | 'high';
    canPurchasePriorityBuilds: boolean;
    numberOfRemainingPriorityBuilds: number;
    hasUnlimitedPriorityBuilds: boolean;
};
export declare function getBuildStatusAsync(projectRoot: string, options?: GetExpConfigOptions): Promise<BuildStatusResult>;
export declare function startBuildAsync(projectRoot: string, options?: GetExpConfigOptions): Promise<BuildCreatedResult>;
export declare function startReactNativeServerAsync({ projectRoot, options, exp, verbose, }: {
    projectRoot: string;
    options: StartOptions;
    exp?: ExpoConfig;
    verbose?: boolean;
}): Promise<void>;
export declare function stopReactNativeServerAsync(projectRoot: string): Promise<void>;
export declare function startExpoServerAsync(projectRoot: string, options: StartOptions): Promise<void>;
export declare function setOptionsAsync(projectRoot: string, options: {
    packagerPort?: number;
}): Promise<void>;
export declare function startAsync(projectRoot: string, { exp, ...options }?: StartOptions & {
    exp?: ExpoConfig;
}, verbose?: boolean): Promise<ExpoConfig>;
export declare function stopWebOnlyAsync(projectDir: string): Promise<void>;
export declare function stopAsync(projectDir: string): Promise<void>;
export { startTunnelsAsync, stopTunnelsAsync };
