{"version":3,"sources":["../../src/appleApi/contractMessages.ts"],"names":["getContractStatusAsync","context","capabilities","ITCAgreements","getCapabilitiesAsync","contractStatus","error","log","warn","message","getContractMessagesAsync","getRequiredContractMessagesAsync","status","includes","messages","isFatal","newLine","rootUrl","formatContractMessage","content","subject","filter","Boolean","join","assertContractMessagesAsync","spinner","Array","isArray","length","stop","chalk","yellow","bold","isDebug","JSON","stringify","addNewLineIfNone","CommandError"],"mappings":"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","sourcesContent":["import { ITCAgreements, RequestContext } from '@expo/apple-utils';\nimport chalk from 'chalk';\nimport { Ora } from 'ora';\n\nimport CommandError from '../CommandError';\nimport log from '../log';\nimport { convertHTMLToASCII } from '../utils/convertHTMLToASCII';\n\nasync function getContractStatusAsync(\n  context: RequestContext\n): Promise<ITCAgreements.ITCContractStatus | null> {\n  try {\n    const capabilities = await ITCAgreements.getCapabilitiesAsync(context);\n    return capabilities?.contractStatus ?? null;\n  } catch (error) {\n    log.warn(`Failed to get iTunes contract status: ${error.message}`);\n    return null;\n  }\n}\n\nasync function getContractMessagesAsync(context: RequestContext) {\n  try {\n    return await ITCAgreements.getContractMessagesAsync(context);\n  } catch (error) {\n    log.warn(`Failed to get iTunes contract messages: ${error.message}`);\n    return null;\n  }\n}\n\nasync function getRequiredContractMessagesAsync(\n  context: RequestContext\n): Promise<{ messages: ITCAgreements.ITCContractMessage[]; isFatal: boolean }> {\n  // This emulates the check that's performed on the ASC website's \"apps\"\n  // page before presenting the (+) create app button.\n  const status = await getContractStatusAsync(context);\n\n  if (status) {\n    if (['FREE_APP_AGREEMENT_ACTIVE', 'PAID_APP_AGREEMENT_ACTIVE'].includes(status)) {\n      // The user can freely create an app, no contracts need to be accepted.\n      // No need to check for messages because afaict no vital messages will be present.\n      return { messages: [], isFatal: false };\n    } else if (\n      ['FREE_APP_AGREEMENT_OUTDATED', 'PAID_APP_AGREEMENT_OUTDATED', 'EXPIRED_MEMBERSHIP'].includes(\n        status\n      )\n    ) {\n      // The user cannot create an app until they've reviewed, and agreed to the updated agreements\n      // or renewed their membership on ASC.\n      // Get the exact messages from ASC to show the user a useful message.\n      return { messages: (await getContractMessagesAsync(context)) ?? [], isFatal: true };\n    }\n  }\n  // The contract messages aren't documented so if a new one is present we cannot be sure if it's fatal or not.\n  // This will check for messages, if none exist, then the process will continue.\n  // Otherwise messages will be present and the process will stop.\n  // There is a small chance that this could result in a false positive if the messages are extraneous, so we'll also\n  // prompt the user to open an issue so we can address the new contract state if it ever appears.\n  // TODO: Maybe a silent analytic would be better\n  log.error(\n    `\\nUnexpected Apple developer contract status \"${status}\". Please open an issue on https://github.com/expo/eas-cli`\n  );\n  log.newLine();\n  return { messages: (await getContractMessagesAsync(context)) ?? [], isFatal: false };\n}\n\nconst rootUrl = 'https://appstoreconnect.apple.com';\n\nexport function formatContractMessage(message: ITCAgreements.ITCContractMessage): string {\n  return convertHTMLToASCII({\n    content:\n      '\\u203A ' +\n      [message.subject && `<b>${message.subject}</b>`, message.message]\n        .filter(Boolean)\n        .join('<br />'),\n    rootUrl,\n  });\n}\n\nexport async function assertContractMessagesAsync(context: RequestContext, spinner?: Ora) {\n  const { messages, isFatal } = await getRequiredContractMessagesAsync(context);\n\n  if (Array.isArray(messages) && messages.length) {\n    if (spinner) {\n      spinner.stop();\n    }\n    log.newLine();\n    log(chalk.yellow.bold('Messages from App Store Connect:'));\n    log.newLine();\n    for (const message of messages) {\n      if (log.isDebug) {\n        log(JSON.stringify(message, null, 2));\n        log.newLine();\n      }\n      log.addNewLineIfNone();\n      log(formatContractMessage(message));\n    }\n    log.addNewLineIfNone();\n    // Only throw an error if we know that the status is fatal, otherwise attempt to finish the process.\n    if (isFatal) {\n      throw new CommandError('App Store Connect has agreement updates that must be resolved');\n    }\n  }\n}\n"],"file":"contractMessages.js"}