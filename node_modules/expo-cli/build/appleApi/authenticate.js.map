{"version":3,"sources":["../../src/appleApi/authenticate.ts"],"names":["APPLE_IN_HOUSE_TEAM_TYPE","getRequestContext","authCtx","authState","context","loginAsync","userCredentials","options","cookies","session","Auth","loginWithCookiesAsync","username","password","resetInMemoryData","restoredSession","tryRestoringAuthStateFromUserCredentialsAsync","providerId","teamId","loginWithUserCredentialsAsync","error","InvalidUserCredentialsError","log","message","AbortCommandError","newSession","authenticateAsync","addNewLineIfNone","autoResolveProvider","teams","Teams","getTeamsAsync","team","find","fastlaneSession","Session","getSessionAsYAML","appleId","appleIdPassword","formatTeam","process","exit","chalk","red","name","type","id","inHouse","toLowerCase"],"mappings":"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","sourcesContent":["import {\n  Auth,\n  InvalidUserCredentialsError,\n  RequestContext,\n  Session,\n  Teams,\n} from '@expo/apple-utils';\nimport chalk from 'chalk';\n\nimport { AbortCommandError } from '../CommandError';\nimport { assert } from '../assert';\nimport log from '../log';\nimport { toggleConfirmAsync } from '../prompts';\nimport {\n  deletePasswordAsync,\n  promptPasswordAsync,\n  resolveCredentialsAsync,\n} from './resolveCredentials';\n\nconst APPLE_IN_HOUSE_TEAM_TYPE = 'in-house';\n\nexport type Options = {\n  appleId?: string;\n  teamId?: string;\n  /**\n   * Can be used to restore the Apple auth state via apple-utils.\n   */\n  cookies?: Session.AuthState['cookies'];\n};\n\nexport type Team = {\n  id: string;\n  name?: string;\n  inHouse?: boolean;\n};\n\nexport type AppleCtx = {\n  appleId: string;\n  appleIdPassword?: string;\n  team: Team;\n  /**\n   * Defined when using Fastlane\n   */\n  fastlaneSession?: string;\n  /**\n   * Can be used to restore the Apple auth state via apple-utils.\n   */\n  authState?: Session.AuthState;\n};\n\nexport function getRequestContext(authCtx: AppleCtx): RequestContext {\n  assert(authCtx.authState?.context, 'Apple request context must be defined');\n  return authCtx.authState.context;\n}\n\nasync function loginAsync(\n  userCredentials: Partial<Auth.UserCredentials> = {},\n  options: Auth.LoginOptions\n): Promise<Session.AuthState> {\n  // First try login with cookies JSON\n  if (userCredentials.cookies) {\n    const session = await Auth.loginWithCookiesAsync(userCredentials);\n    // If the session isn't valid, continue to the other authentication methods.\n    // Use `loginWithCookiesAsync` for a less resilient flow.\n    if (session) {\n      return session;\n    }\n  }\n\n  // Resolve the user credentials, optimizing for password-less login.\n  const { username, password } = await resolveCredentialsAsync(userCredentials);\n  assert(username);\n\n  // Clear data\n  Auth.resetInMemoryData();\n\n  try {\n    // Attempt to rehydrate the session.\n    const restoredSession = await Auth.tryRestoringAuthStateFromUserCredentialsAsync(\n      {\n        username,\n        providerId: userCredentials.providerId,\n        teamId: userCredentials.teamId,\n      },\n      options\n    );\n    if (restoredSession) {\n      // Completed authentication!\n      return { password, ...restoredSession };\n    }\n\n    return await loginWithUserCredentialsAsync({\n      username,\n      password,\n      providerId: userCredentials.providerId,\n      teamId: userCredentials.teamId,\n    });\n  } catch (error) {\n    if (error instanceof InvalidUserCredentialsError) {\n      log.error(error.message);\n      // Remove the invalid password so it isn't automatically used...\n      await deletePasswordAsync({ username });\n\n      if (await toggleConfirmAsync({ message: 'Would you like to try again?' })) {\n        // Don't pass credentials back or the method will throw\n        return loginAsync(\n          {\n            teamId: userCredentials.teamId,\n            providerId: userCredentials.providerId,\n          },\n          options\n        );\n      } else {\n        throw new AbortCommandError();\n      }\n    }\n    throw error;\n  }\n}\n\nasync function loginWithUserCredentialsAsync({\n  username,\n  password,\n  teamId,\n  providerId,\n}: {\n  username: string;\n  password?: string;\n  teamId?: string;\n  providerId?: number;\n}) {\n  // Start a new login flow\n  const newSession = await Auth.loginWithUserCredentialsAsync({\n    username,\n    // If the session couldn't be restored, then prompt for the password (also check if it's stored in the keychain).\n    password: password || (await promptPasswordAsync({ username })),\n    providerId,\n    teamId,\n  });\n  // User cancelled or something.\n  assert(newSession, 'An unexpected error occurred while completing authentication');\n\n  // Success!\n  return newSession;\n}\n\nexport async function authenticateAsync(options: Options = {}): Promise<AppleCtx> {\n  // help keep apple login visually apart from the other operations.\n  log.addNewLineIfNone();\n\n  try {\n    const authState = await loginAsync(\n      {\n        cookies: options.cookies,\n        teamId: options.teamId,\n      },\n      {\n        // TODO: Provide a way to disable this for users who want to mix and match teams / providers.\n        autoResolveProvider: true,\n      }\n    );\n\n    // Currently, this is resolved once, inside the apple-utils package.\n    const teamId = authState.context.teamId!;\n    // Get all of the teams to resolve the rest of the user data.\n    // TODO: optimize this step.\n    const teams = await Teams.getTeamsAsync();\n    const team = teams.find(team => team.teamId === teamId);\n    assert(team, `Your account is not associated with Apple Team with ID: ${teamId}`);\n\n    // Get the JSON cookies in the custom YAML format used by Fastlane\n    const fastlaneSession = Session.getSessionAsYAML();\n    return {\n      appleId: authState.username,\n      appleIdPassword: authState.password,\n      team: formatTeam(team),\n      // Can be used to restore the auth state using apple-utils.\n      authState,\n      // Defined for legacy usage in Turtle V1 or any other places where Fastlane is used in the servers.\n      fastlaneSession,\n    };\n  } catch (error) {\n    if (error.message === 'ABORTED') {\n      process.exit(1);\n    }\n    log(chalk.red('Authentication with Apple Developer Portal failed!'));\n    throw error;\n  }\n}\n\nfunction formatTeam({ teamId, name, type }: Teams.AppStoreTeam): Team {\n  return {\n    id: teamId,\n    name: `${name} (${type})`,\n    inHouse: type.toLowerCase() === APPLE_IN_HOUSE_TEAM_TYPE,\n  };\n}\n"],"file":"authenticate.js"}